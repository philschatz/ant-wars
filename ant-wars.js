// Generated by CoffeeScript 1.3.3
(function() {
  var AHEAD, ANT_CLASSES, ANT_LAYER, Ant, DIR_LEFT, DIR_LEFT_DOWN, DIR_LEFT_UP, DIR_RIGHT, DIR_RIGHT_DOWN, DIR_RIGHT_UP, Drop, FOOD_LAYER, Flip, Instruction, LEFT, MAP, MAP_LAYER, Map, MapTile, Mark, Move, NO_TILE, PickUp, RADIUS, RED_BRAIN, RIGHT, SENSE_FOE, SENSE_FOE_FOOD, SENSE_FOE_HOME, SENSE_FOE_MARKER, SENSE_FOOD, SENSE_FRIEND, SENSE_FRIEND_FOOD, SENSE_HOME, SENSE_ROCK, Sense, TILE_CLASSES, Tile, Turn, Unmark, char, dx, dy, height, hexagon, mapBoard, mapBoardSMALL, margin, newDir, newXY, points, randomX, randomY, row, rowStr, svg, update, width, _i, _j, _len, _len1, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  SENSE_FRIEND = -1;

  SENSE_FOE = -2;

  SENSE_FRIEND_FOOD = -3;

  SENSE_FOE_FOOD = -4;

  SENSE_FOOD = -5;

  SENSE_ROCK = -6;

  SENSE_HOME = -7;

  SENSE_FOE_HOME = -8;

  SENSE_FOE_MARKER = -9;

  DIR_RIGHT = 0;

  DIR_RIGHT_DOWN = 1;

  DIR_LEFT_DOWN = 2;

  DIR_LEFT = 3;

  DIR_LEFT_UP = 4;

  DIR_RIGHT_UP = 5;

  newXY = function(dir, x, y) {
    switch (dir) {
      case DIR_RIGHT:
        return [x + 1, y];
      case DIR_LEFT:
        return [x - 1, y];
      case DIR_RIGHT_DOWN:
        return [x, y + 1];
      case DIR_LEFT_DOWN:
        return [x - 1, y + 1];
      case DIR_RIGHT_UP:
        return [x + 1, y - 1];
      case DIR_LEFT_UP:
        return [x, y - 1];
      default:
        throw 'BUG: Invalid Direction!';
    }
  };

  LEFT = -1;

  RIGHT = 1;

  AHEAD = 0;

  newDir = function(dir, leftOrRight) {
    switch (leftOrRight) {
      case LEFT:
        return (dir + 6 - 1) % 6;
      case RIGHT:
        return (dir + 6 + 1) % 6;
      case AHEAD:
        return dir;
      default:
        throw 'BUG: Invalid Direction!';
    }
  };

  Instruction = (function() {

    function Instruction() {}

    Instruction.prototype.execute = function(map, ant) {
      throw 'BUG: Subclass must implement!';
    };

    return Instruction;

  })();

  Sense = (function(_super) {

    __extends(Sense, _super);

    function Sense(sensedir, st1, st2, cond) {
      this.sensedir = sensedir;
      this.st1 = st1;
      this.st2 = st2;
      this.cond = cond;
    }

    Sense.prototype.execute = function(map, ant) {
      var found, x, y, _ref;
      _ref = newXY(newDir(ant.direction, this.sensedir), ant.x, ant.y), x = _ref[0], y = _ref[1];
      found = (function() {
        var _ref1, _ref2, _ref3, _ref4;
        switch (this.cond) {
          case SENSE_ROCK:
            return map.getTileAt(x, y).isRock();
          case SENSE_FRIEND:
            return (_ref1 = map.getAntAt(x, y)) != null ? _ref1.isFriend(ant) : void 0;
          case SENSE_FOE:
            return (_ref2 = map.getAntAt(x, y)) != null ? _ref2.isFoe(ant) : void 0;
          case SENSE_FRIEND_FOOD:
            return (_ref3 = map.getAntAt(x, y)) != null ? _ref3.isFriend(ant).hasFood : void 0;
          case SENSE_FOE_FOOD:
            return (_ref4 = map.getAntAt(x, y)) != null ? _ref4.isFoe(ant).hasFood : void 0;
          case SENSE_FOOD:
            return map.hasFood(x, y);
          case SENSE_HOME:
            return map.getTileAt(x, y).isHomeAndMatches(ant);
          case SENSE_FOE_HOME:
            return map.getTileAt(x, y).isHomeAndMatchesFoe(ant);
          case SENSE_FOE_MARKER:
            throw 'BUG: Unimplemented!';
            break;
          default:
            throw 'BUG: Unimplemented!';
        }
      }).call(this);
      if (found) {
        return this.st1;
      }
      return this.st2;
    };

    return Sense;

  })(Instruction);

  Mark = (function(_super) {

    __extends(Mark, _super);

    function Mark(i, st) {
      this.i = i;
      this.st = st;
    }

    return Mark;

  })(Instruction);

  Unmark = (function(_super) {

    __extends(Unmark, _super);

    function Unmark(i, st) {
      this.i = i;
      this.st = st;
    }

    return Unmark;

  })(Instruction);

  PickUp = (function(_super) {

    __extends(PickUp, _super);

    function PickUp(st1, st2) {
      this.st1 = st1;
      this.st2 = st2;
    }

    PickUp.prototype.execute = function(map, ant) {
      var pickedUp;
      if (ant.hasFood) {
        return this.st2;
      }
      pickedUp = map.pickupFood(ant.x, ant.y);
      if (pickedUp) {
        ant.hasFood = true;
        return this.st1;
      } else {
        return this.st2;
      }
    };

    return PickUp;

  })(Instruction);

  Drop = (function(_super) {

    __extends(Drop, _super);

    function Drop(st) {
      this.st = st;
    }

    Drop.prototype.execute = function(map, ant) {
      if (ant.hasFood) {
        map.dropFood(ant.x, ant.y);
        ant.hasFood = false;
      }
      return this.st;
    };

    return Drop;

  })(Instruction);

  Turn = (function(_super) {

    __extends(Turn, _super);

    function Turn(lr, st) {
      this.lr = lr;
      this.st = st;
    }

    Turn.prototype.execute = function(map, ant) {
      ant.direction = newDir(ant.direction, this.lr);
      return this.st;
    };

    return Turn;

  })(Instruction);

  Move = (function(_super) {

    __extends(Move, _super);

    function Move(st1, st2) {
      this.st1 = st1;
      this.st2 = st2;
    }

    Move.prototype.execute = function(map, ant) {
      var x, y, _ref;
      _ref = newXY(ant.direction, ant.x, ant.y), x = _ref[0], y = _ref[1];
      if (map.isEmpty(x, y)) {
        map.moveAnt(ant, x, y);
        return this.st1;
      } else {
        return this.st2;
      }
    };

    return Move;

  })(Instruction);

  Flip = (function(_super) {

    __extends(Flip, _super);

    function Flip(p, st1, st2) {
      this.p = p;
      this.st1 = st1;
      this.st2 = st2;
    }

    Flip.prototype.execute = function(map, ant) {
      switch (Math.floor(Math.random() * 6)) {
        case 0:
          return this.st1;
        default:
          return this.st2;
      }
    };

    return Flip;

  })(Instruction);

  Tile = (function() {

    function Tile(x, y, char) {
      this.x = x;
      this.y = y;
      this.char = char;
    }

    Tile.prototype.toString = function() {
      return "" + this.x + "-" + this.y + "-" + this.char;
    };

    Tile.prototype.getClasses = function() {
      return TILE_CLASSES[this.char];
    };

    return Tile;

  })();

  MapTile = (function(_super) {

    __extends(MapTile, _super);

    function MapTile() {
      return MapTile.__super__.constructor.apply(this, arguments);
    }

    MapTile.prototype.isRock = function() {
      return '#' === this.char;
    };

    MapTile.prototype.isHomeAndMatches = function(ant) {
      switch (this.char) {
        case '-':
          return ant.char === '-';
        case '+':
          return ant.char === '+';
        default:
          return false;
      }
    };

    MapTile.prototype.isHomeAndMatchesFoe = function(ant) {
      switch (this.char) {
        case '-':
          return ant.char === '+';
        case '+':
          return ant.char === '-';
        default:
          return false;
      }
    };

    return MapTile;

  })(Tile);

  NO_TILE = new MapTile(-1, -1, '?');

  Ant = (function(_super) {
    var id;

    __extends(Ant, _super);

    id = 0;

    function Ant(x, y, char) {
      this.x = x;
      this.y = y;
      this.char = char;
      this.id = id++;
      this.programCounter = 0;
      this.direction = 0;
      this.hasFood = false;
    }

    Ant.prototype.getClasses = function() {
      return "" + ANT_CLASSES[this.char] + (this.hasFood ? ' has-food' : '');
    };

    Ant.prototype.toString = function() {
      return this.id;
    };

    return Ant;

  })(Tile);

  Map = (function() {
    var ants, food, tiles;

    function Map() {}

    ants = {};

    tiles = {};

    food = {};

    Map.prototype.addAnt = function(ant) {
      return ants["" + ant.x + "-" + ant.y] = ant;
    };

    Map.prototype.addTile = function(tile) {
      return tiles["" + tile.x + "-" + tile.y] = tile;
    };

    Map.prototype.isEmpty = function(x, y) {
      var tile;
      tile = tiles["" + x + "-" + y];
      if (!tile) {
        throw 'Invalid coords';
      }
      if (tile.isRock()) {
        return false;
      }
      return !ants["" + x + "-" + y];
    };

    Map.prototype.hasFood = function(x, y) {
      return food["" + x + "-" + y];
    };

    Map.prototype.dropFood = function(x, y, amount) {
      var count;
      if (amount == null) {
        amount = 1;
      }
      count = food["" + x + "-" + y] || 0;
      return food["" + x + "-" + y] = count + amount;
    };

    Map.prototype.pickupFood = function(x, y) {
      var count;
      count = food["" + x + "-" + y] || 0;
      if (!count) {
        return false;
      }
      food["" + x + "-" + y] = count - 1;
      return true;
    };

    Map.prototype.moveAnt = function(ant, x, y) {
      delete ants["" + ant.x + "-" + ant.y];
      ant.x = x;
      ant.y = y;
      return ants["" + ant.x + "-" + ant.y] = ant;
    };

    Map.prototype.getTileAt = function(x, y) {
      return tiles["" + x + "-" + y] || NO_TILE;
    };

    Map.prototype.getTiles = function() {
      return d3.values(tiles);
    };

    Map.prototype.getAnts = function() {
      return d3.values(ants);
    };

    Map.prototype.getFoods = function() {
      var foods, tile, _i, _len, _ref;
      foods = [];
      _ref = this.getTiles();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tile = _ref[_i];
        if (this.hasFood(tile.x, tile.y)) {
          foods.push(new Tile(tile.x, tile.y, '@'));
        }
      }
      return foods;
    };

    return Map;

  })();

  RED_BRAIN = [new Sense(AHEAD, 1, 3, SENSE_FOOD), new Move(2, 0), new PickUp(8, 0), new Flip(3, 4, 5), new Turn(LEFT, 0), new Flip(2, 6, 7), new Turn(RIGHT, 0), new Move(0, 3), new Sense(AHEAD, 9, 11, SENSE_HOME), new Move(10, 8), new Drop(0), new Flip(3, 12, 13), new Turn(LEFT, 8), new Flip(2, 14, 15), new Turn(RIGHT, 8), new Move(8, 11)];

  MAP = new Map();

  window.MAP = MAP;

  update = function(layer, data) {
    var grid;
    grid = layer.selectAll('.hexagon').data(data, function(p) {
      return p.toString();
    });
    grid.attr('transform', function(d) {
      var dx, dy;
      dx = RADIUS + d.x * RADIUS * 1.74;
      dy = RADIUS + d.y * RADIUS * 1.5;
      if (d.y % 2 !== 0) {
        dx = dx + RADIUS * .9;
      }
      return "translate(" + dx + "," + dy + ")";
    }).attr('class', function(d) {
      return "hexagon " + (d.getClasses());
    });
    grid.enter().append('path').attr('d', hexagon(RADIUS)).attr('transform', function(d) {
      var dx, dy;
      dx = RADIUS + d.x * RADIUS * 1.74;
      dy = RADIUS + d.y * RADIUS * 1.5;
      if (d.y % 2 !== 0) {
        dx = dx + RADIUS * .9;
      }
      return "translate(" + dx + "," + dy + ")";
    }).attr('class', function(d) {
      return "hexagon " + (d.getClasses());
    });
    return grid.exit().remove();
  };

  margin = {
    top: 20,
    right: 20,
    bottom: 30,
    left: 40
  };

  width = 960 - margin.left - margin.right;

  height = 500 - margin.top - margin.bottom;

  randomX = d3.random.normal(width / 2, 80);

  randomY = d3.random.normal(height / 2, 80);

  points = d3.range(2000).map(function() {
    return [randomX(), randomY()];
  });

  RADIUS = 10;

  hexagon = function(radius) {
    var hex, hexAngles;
    hexAngles = d3.range(0, 2 * Math.PI, Math.PI / 3);
    hex = function(radius) {
      var x0, y0;
      x0 = 0;
      y0 = 0;
      return hexAngles.map(function(angle) {
        var dx, dy, x1, y1;
        x1 = Math.sin(angle) * radius;
        y1 = -Math.cos(angle) * radius;
        dx = x1 - x0;
        dy = y1 - y0;
        x0 = x1;
        y0 = y1;
        return [dx, dy];
      });
    };
    return "m" + (hex(radius).join('l')) + "z";
  };

  width = RADIUS * 2 * 100;

  height = RADIUS * 2 * 100;

  svg = d3.select('body').append('svg').attr('width', width + margin.left + margin.right).attr('height', height + margin.top + margin.bottom).append('g').attr('transform', "translate(" + margin.left + "," + margin.top + ")");

  svg.append('clipPath').attr('id', 'clip').append('rect').attr('class', 'mesh').attr('width', width).attr('height', height);

  mapBoard = '# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #\n# . . . . . . - - - - - - . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . + + + + + + . . . . . #\n # . . . . . - - - - - - - . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . + + + + + + + . . . . . #\n# . . . . . - - - - - - - - . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . + + + + + + + + . . . . #\n # . . . . - - - - - - - - - . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . + + + + + + + + + . . . . #\n# . . . . - - - - - - - - - - . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . + + + + + + + + + + . . . #\n # . . . - - - - - - - - - - - . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . + + + + + + + + + + + . . . #\n# . . . . - - - - - - - - - - . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . + + + + + + + + + + . . . #\n # . . . . - - - - - - - - - . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . + + + + + + + + + . . . . #\n# . . . . . - - - - - - - - . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . + + + + + + + + . . . . #\n # . . . . . - - - - - - - . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . + + + + + + + . . . . . #\n# . . . . . . - - - - - - . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . + + + + + + . . . . . #\n # . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . #\n # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #';

  mapBoardSMALL = '# # # # # # # # # #\n # . . . . . . . . #\n# . - - . . . . . #\n # . - . . . . . . #\n# . . . . . . . . #\n # . . . 2 . . . . #\n# . . . 2 2 . . . #\n # . . . 2 . . . . #\n# . . . . . . . . #\n # . . . . . + . . #\n# . . . . . + + . #\n # . . . . . . . . #\n# # # # # # # # # #';

  TILE_CLASSES = {
    '+': 'tile red-home',
    '-': 'tile blue-home',
    '.': 'tile grass',
    '#': 'tile wall',
    '@': 'tile food'
  };

  ANT_CLASSES = {
    '-': 'ant blue',
    '+': 'ant red'
  };

  _ref = mapBoard.split('\n');
  for (dy = _i = 0, _len = _ref.length; _i < _len; dy = ++_i) {
    rowStr = _ref[dy];
    row = rowStr.trim().split(' ');
    for (dx = _j = 0, _len1 = row.length; _j < _len1; dx = ++_j) {
      char = row[dx];
      switch (char) {
        case '.':
          MAP.addTile(new MapTile(dx, dy, char));
          break;
        case '#':
          MAP.addTile(new MapTile(dx, dy, char));
          break;
        case '-':
          MAP.addTile(new MapTile(dx, dy, char));
          MAP.addAnt(new Ant(dx, dy, char));
          break;
        case '+':
          MAP.addTile(new MapTile(dx, dy, char));
          MAP.addAnt(new Ant(dx, dy, char));
          break;
        default:
          MAP.addTile(new MapTile(dx, dy, '.'));
          MAP.dropFood(dx, dy, parseInt(char));
      }
    }
  }

  MAP_LAYER = svg.append('g').attr('clip-path', 'url(#clip)');

  FOOD_LAYER = svg.append('g').attr('clip-path', 'url(#clip)');

  ANT_LAYER = svg.append('g').attr('clip-path', 'url(#clip)');

  update(MAP_LAYER, MAP.getTiles());

  setInterval((function() {
    var ant, ants, _k, _len2, _results;
    ants = MAP.getAnts();
    _results = [];
    for (_k = 0, _len2 = ants.length; _k < _len2; _k++) {
      ant = ants[_k];
      _results.push(ant.programCounter = RED_BRAIN[ant.programCounter].execute(MAP, ant));
    }
    return _results;
  }), 10);

  setInterval((function() {
    update(FOOD_LAYER, MAP.getFoods());
    return update(ANT_LAYER, MAP.getAnts());
  }), 10);

}).call(this);
